import os
from datetime import datetime
from enum import Enum
from logging import getLogger
from typing import TYPE_CHECKING, Callable, Literal, overload

import numpy as np
import polars as pl
from pydantic import NonNegativeInt, model_validator
from pydantic_xml import BaseXmlModel, attr, element

from kithairon._util import _WELL_ALPHABET

from .labware import Labware

log = getLogger(__name__)


class SurveyType(Enum):
    MEDMAN = 1
    REPORT = 2
    UNKNOWN = 3


if TYPE_CHECKING:  # pragma: no cover
    import matplotlib.pyplot as plt  # noqa
    from matplotlib.axes import Axes


class WellSurvey(BaseXmlModel, tag="w"):
    row: NonNegativeInt = attr(name="r")
    column: NonNegativeInt = attr(name="c")
    well: str = attr(name="n")
    volume: float = attr(name="vl")
    current_volume: float = attr(name="cvl")
    status: str = attr()
    fluid: str = attr(name="fld")
    fluid_units: str = attr(name="fldu")
    meniscus_x: float = attr(name="x")
    meniscus_y: float = attr(name="y")
    s_value_fixme: float = attr(name="s")
    dmso_homogeneous: float = attr(name="fsh")
    dmso_imhomogeneous: float = attr(name="fsinh")
    fluid_thickness: float = attr(name="t")
    current_fluid_thickness: float = attr(name="ct")
    bottom_thickness: float = attr(name="b")
    fluid_thickness_homogeneous: float = attr(name="fth")
    fluid_thickness_imhomogeneous: float = attr(name="ftinh")
    outlier: float = attr(name="o")
    corrective_action: str = attr(name="a")


class SignalFeature(BaseXmlModel, tag="f"):
    feature_type: str = attr(name="t")
    tof: float = attr(name="o")
    vpp: float = attr(name="v")


class EchoSignal(BaseXmlModel, tag="e"):
    signal_type: str = attr(name="t")
    transducer_x: float = attr(name="x")
    transducer_y: float = attr(name="y")
    transducer_z: float = attr(name="z")
    features: list[SignalFeature]


class PlateSurveyXML(BaseXmlModel, tag="platesurvey"):
    """A platesurvey XML model for files generated by the Medman / 'Echo Liquid Handler' software."""

    plate_type: str = attr(name="name")
    """The `name` attribute.  Practically appears to always be the plate type."""
    plate_barcode: str = attr(name="barcode")
    """Plate barcode, if present, or `"UnknownBarCode"`. `barcode` attribute."""
    timestamp: datetime = attr(name="date")
    """Timestamp of the survey.  `date` attribute."""
    machine_serial_number: str = attr(name="serial_number")
    vtl: int = attr(name="vtl")  # fixme
    original: int = attr(name="original")  # fixme
    data_format_version: int = attr(name="frmt")  # fixme
    rows: int = attr(name="rows")
    columns: int = attr(name="cols")
    total_wells: int = attr(name="totalWells")
    wells: list[WellSurvey]
    plate_name: str | None = attr(name="plate_name", default=None)
    """Plate name.  Additional attribute, added by echo_utils."""
    note: str | None = attr(name="note", default=None)
    """Comment.  Additional attribute, added by echo_utils."""


class EchoReportHeader(BaseXmlModel, tag="reportheader"):
    RunID: str = element()
    RunDateTime: datetime = element()
    AppName: str = element()
    AppVersion: str = element()
    ProtocolName: str = element()
    OrderID: str = element()  # FIXME
    ReferenceID: str = element()  # FIXME
    UserName: str = element()
    Comment: str | None = element(default=None)
    """Comment. Additional element, added by echo_utils."""

    @model_validator(mode="after")
    def warn_on_untested_versions(self) -> "EchoReportHeader":
        version = self.AppVersion
        version_triple = version.split(".")
        if len(version_triple) != 3:
            log.warning(
                f"Unexpected version format {self.AppVersion} for {self.AppName}.  There may be errors in parsing."
            )
            return self
        major, minor, patch = version_triple

        match self.AppName:
            case "Echo Plate Reformat" | "Echo Cherry Pick":
                if major != "1":
                    log.warning(
                        f"Unexpected major version {version} for {self.AppName}.  There may be errors in parsing. This library has been tested on 1.8.2."
                    )
                elif minor != "8":
                    log.warning(
                        f"Untested minor version {version} for {self.AppName}.  There may be errors in parsing.  This library has been tested on 1.8.2."
                    )
                elif patch != "2":
                    log.info(
                        f"Untested patch version {version} for {self.AppName}.  This library has been tested on 1.8.2."
                    )
            case _:
                log.warning(
                    f"Unknown application {self.AppName} {version} generated this survey.  There may be errors in parsing."
                )

        return self


class EchoReportRecord(BaseXmlModel, tag="record"):
    SrcPlateName: str = element()
    """The name of the plate surveyed (necessarily a source plate for a ReportRecord).

    .. warning::

        It is not currently known whether multiple plates can be present in a single report, or
        if this is just redundantly specified for every well.
    """
    SrcPlateBarcode: str = element()
    """The barcode of the plate surveyed (necessarily a source plate for a ReportRecord).

    .. warning::

        It is not currently known whether multiple plates can be present in a single report, or
        if this is just redundantly specified for every well.
    """
    SrcPlateType: str = element()
    """The surveyed plate type.

    .. warning::

        It is not currently known whether multiple plate types can be present in a single report, or
        if this is just redundantly specified for every well.
    """
    SrcWell: str = element()
    """The surveyed well, in standard, non-zero padded format (eg, "A1" or "C12", not "A01")."""
    SurveyFluidHeight: float = element()
    SurveyFluidVolume: float = element()
    FluidComposition: float = element()  # FIXME
    FluidUnits: str = element()  # FIXME
    FluidType: str = element()
    SurveyStatus: str = element()  # FIXME)


class EchoReportFooter(BaseXmlModel, tag="reportfooter"):
    InstrName: str = element()
    InstrModel: str = element()
    InstrSN: str = element()
    InstrSWVersion: str = element()


class EchoReportBody(BaseXmlModel, tag="reportbody"):
    records: list[EchoReportRecord]

    @model_validator(mode="after")
    def check_equal_plate_names(self) -> "EchoReportBody":
        if len(names := set([r.SrcPlateName for r in self.records])) != 1:
            raise ValueError(
                f"All records must have the same SrcPlateName, but the names {names} were found. "
                "This is unexpected but supported by the format, please file an issue."
            )
        return self

    @model_validator(mode="after")
    def check_equal_plate_barcodes(self) -> "EchoReportBody":
        if len(barcodes := set([r.SrcPlateBarcode for r in self.records])) != 1:
            raise ValueError(
                f"All records must have the same SrcPlateBarcode, but the barcodes {barcodes} were found. "
                "This is unexpected but supported by the format, please file an issue."
            )
        return self

    @model_validator(mode="after")
    def check_equal_plate_types(self) -> "EchoReportBody":
        if len(types := set([r.SrcPlateType for r in self.records])) != 1:
            raise ValueError(
                f"All records must have the same SrcPlateType, but the types {types} were found. "
                "This is unexpected but supported by the format, please file an issue."
            )
        return self


class EchoSurveyReport(BaseXmlModel, tag="report"):
    reportheader: EchoReportHeader
    reportbody: EchoReportBody
    reportfooter: EchoReportFooter


class Survey:
    """An class for all Echo plate surveys.

    This class holds results from Echo plate surveys, regardless of source.  It currently
    supports:

      - Medman / raw surveys
      - Cherry Pick and Plate Reformat surveys
    """

    raw: PlateSurveyXML | EchoSurveyReport

    @property
    def plate_barcode(self) -> str | None:
        "The plate barcode, or None if not present."
        match self.raw:
            case PlateSurveyXML():
                bc = self.raw.plate_barcode
            case EchoSurveyReport():
                bc = self.raw.reportbody.records[0].SrcPlateBarcode  # FIXME
            case _:
                raise ValueError("Unknown survey type")
        if bc == "UnknownBarCode":
            return None
        else:
            return bc

    @property
    def plate_name(self) -> str | None:
        "The plate name, if present (may not be present in Medman surveys)."
        match self.raw:
            case PlateSurveyXML():
                return self.raw.plate_name
            case EchoSurveyReport():
                return self.raw.reportbody.records[0].SrcPlateName

    @plate_name.setter
    def plate_name(self, value: str | None) -> None:
        match self.raw:
            case PlateSurveyXML():
                self.raw.plate_name = value
            case EchoSurveyReport():
                for record in self.raw.reportbody.records:
                    record.SrcPlateName = value if value is not None else ""  # FIXME

    @property
    def date(self) -> datetime | None:
        """The date of the survey, as a datetime object."""
        match self.raw:
            case PlateSurveyXML():
                return self.raw.timestamp
            case EchoSurveyReport():
                return self.raw.reportheader.RunDateTime
            case _:
                raise ValueError("Unknown survey type")

    @property
    def well_extents(self) -> tuple[int, int, int, int]:
        """Return the extents of the wells in the survey, as (rstart, rend, cstart, cend).)"""
        df = self._dataframe
        return (
            df.get_column("row").min(),
            df.get_column("row").max() + 1,  # type: ignore
            df.get_column("column").min(),
            df.get_column("column").max() + 1,  # type: ignore
        )  # type: ignore

    @property
    def shape(self) -> tuple[int, int]:
        "The shape of the survey.  This may differ from the full plate size."
        return (
            self.well_extents[1] - self.well_extents[0],
            self.well_extents[3] - self.well_extents[2],
        )

    @property
    def plate_type(self) -> str:
        "The plate type surveyed (as a string)."
        match self.raw:
            case PlateSurveyXML():
                return self.raw.plate_type
            case EchoSurveyReport():
                return self.raw.reportbody.records[0].SrcPlateType
            case _:
                raise ValueError("Unknown survey type")

    @plate_type.setter
    def plate_type(self, value: str) -> None:
        match self.raw:
            case PlateSurveyXML():
                self.raw.plate_type = value
            case EchoSurveyReport():
                for record in self.raw.reportbody.records:
                    record.SrcPlateType = value

    @property
    def _dataframe(self) -> pl.DataFrame:
        match self.raw:
            case PlateSurveyXML():
                return pl.DataFrame(
                    {
                        "well": [w.well for w in self.raw.wells],
                        "row": [w.row for w in self.raw.wells],
                        "column": [w.column for w in self.raw.wells],
                        "volume": [w.volume for w in self.raw.wells],
                    }
                )
            case EchoSurveyReport():
                return pl.DataFrame(
                    {
                        "well": [r.SrcWell for r in self.raw.reportbody.records],
                        "row": [
                            _WELL_ALPHABET.index(r.SrcWell[0])
                            for r in self.raw.reportbody.records
                        ],
                        "column": [
                            int(r.SrcWell[1:]) - 1 for r in self.raw.reportbody.records
                        ],
                        "volume": [
                            r.SurveyFluidVolume for r in self.raw.reportbody.records
                        ],
                    }
                )
            case _:
                raise ValueError("Unknown survey type")

    @overload
    def volumes_array(
        self,
        *,
        full_plate: bool | None = None,
        labware: Labware | None = None,
        _return_full_plate_decision: Literal[True],
    ) -> tuple[np.ndarray, bool]:
        ...

    @overload
    def volumes_array(
        self,
        *,
        full_plate: bool | None = None,
        labware: Labware | None = None,
        _return_full_plate_decision: Literal[False],
    ) -> np.ndarray:
        ...

    @overload
    def volumes_array(
        self, *, full_plate: bool | None = None, labware: Labware | None = None
    ) -> np.ndarray:
        ...

    def volumes_array(
        self,
        *,
        full_plate: bool | None = None,
        labware: Labware | None = None,
        _return_full_plate_decision: bool = False,
    ) -> np.ndarray | tuple[np.ndarray, bool]:
        """Return an array of well volumes from the survey.

        Parameters
        ----------
        full_plate : bool | None, optional
            Return the full plate (requires labware definitions), or just the region surveyed, by default None, which chooses
            based on whether labware definitions available for the plate type.
        labware : Labware | None, optional
            Labware definitions, by default None, which tries to load from the module default (not yet implemented).

        Returns
        -------
        np.ndarray
            Surveyed well volumes, in µL.  Un-surveyed wells are np.nan.  Failures are 0.
        """
        match full_plate:
            case True:
                if labware is None:
                    raise ValueError("Labware definitions required for full_plate")
                try:
                    shape: tuple[int, int] = labware[self.plate_type].shape
                    full_plate = True
                except KeyError:
                    raise ValueError(
                        f"Labware definitions for {self.plate_type} not found"
                    )
            case False:
                we = self.well_extents
                shape = self.shape
            case None:
                if labware is None:
                    shape = (
                        self.well_extents[1] - self.well_extents[0],
                        self.well_extents[3] - self.well_extents[2],
                    )
                    full_plate = False
                else:
                    try:
                        shape = labware[self.plate_type].shape
                        full_plate = True
                    except KeyError:
                        we = self.well_extents
                        full_plate = False
                        shape = self.shape
            case _:
                raise TypeError(f"Invalid value for full_plate: {full_plate}")

        arr = np.full(shape, np.nan)

        we = self.well_extents
        df = self._dataframe
        if full_plate:
            arr[df["row"], df["column"]] = df["volume"]
        else:
            arr[df["row"] - we[0], df["column"] - we[2]] = df["volume"]

        if _return_full_plate_decision:
            return arr, full_plate
        else:
            return arr

    def plot_volumes(
        self,
        *,
        full_plate: bool | None = None,
        labware: Labware | None = None,
        ax: "Axes | None" = None,
        annot: bool = True,
        annot_fmt: str = ".0f",
        cbar: bool = False,
        title: str | Callable | None = None,
        vmin: float | None = 0,
        vmax: float | None = None,
        cmap: str | None = None,
    ) -> "Axes":
        """Plot the volumes in the survey.

        Parameters
        ----------
        full_plate : bool | None, optional
            Return the full plate (may require labware definitions), by default None (see :meth:`volumes_array`)
        labware : Labware | None, optional
            Labware definitions, by default None (see :meth:`volumes_array`)
        ax : Axes | None, optional
            Axes to use
        annot : bool, optional
            Annotate well volumes, by default True
        annot_fmt : str, optional
            Format string for annotations, by default ".0f"
        cbar : bool, optional
            Whether to include a colorbar, by default False
        title : str | Callable | None, optional
            Plot title, by default None (a default title is generated). If a callable, it is called with the survey as an argument.
            If a string, it is used as a f-string with the survey as an argument (eg, `"{plate_barcode}".format(survey)`).
        vmin : float | None, optional
            Minimum plot value for colors, by default 0
        vmax : float | None, optional
            Maximum plot value for colors, by default None
        cmap : str | None, optional
            Colormap to use, by default None

        Returns
        -------
        Axes
        """

        from kithairon._util import plot_plate_array

        rstart, _, cstart, _ = self.well_extents
        va, is_full_plate = self.volumes_array(
            full_plate=full_plate, labware=labware, _return_full_plate_decision=True
        )

        ax = plot_plate_array(
            va,
            annot=annot,
            annot_fmt=annot_fmt,
            cbar=cbar,
            vmin=vmin,
            vmax=vmax,
            cmap=cmap,
            ax=ax,
            topleft_offset=(0, 0) if is_full_plate else (rstart, cstart),
        )

        if title is None:
            te = ["Volumes"]
            if self.plate_barcode:
                te.append(f"of {self.plate_barcode}")
            if self.date:
                te.append(f"on {self.date}")
            title = " ".join(te)
        elif isinstance(title, str):
            title = title.format(self)
        else:
            title = title(self)

        assert isinstance(title, str)

        ax.set_title(title)
        return ax

    def __init__(self, raw: PlateSurveyXML | EchoSurveyReport):
        self.raw = raw

    @classmethod
    def from_file(cls, path: os.PathLike | str) -> "Survey":
        """Create a Survey from an XML string."""
        xml_data = open(path, "rb").read()

        errors = []

        try:
            raw = PlateSurveyXML.from_xml(xml_data)
            return cls(raw)
        except Exception as e:
            errors.append(e)
            pass

        try:
            raw = EchoSurveyReport.from_xml(xml_data)
            return cls(raw)
        except Exception as e:
            errors.append(e)
            pass

        raise ValueError(f"Cannot parse {path} as a survey: {errors}") from Exception(
            errors
        )
