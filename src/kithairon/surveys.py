import functools
import os
from datetime import datetime
from enum import Enum
from logging import getLogger
from typing import TYPE_CHECKING, Callable, cast

import numpy as np
import polars as pl
from pydantic import PositiveInt, model_validator
from pydantic_xml import BaseXmlModel, attr, element

log = getLogger(__name__)


class SurveyType(Enum):
    MEDMAN = 1
    REPORT = 2
    UNKNOWN = 3


if TYPE_CHECKING:
    import matplotlib.pyplot as plt
    from matplotlib.axes import Axes


_WELL_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"


class WellSurvey(BaseXmlModel, tag="w"):
    row: PositiveInt = attr(name="r")
    column: PositiveInt = attr(name="c")
    well: str = attr(name="n")
    volume: float = attr(name="vl")
    current_volume: float = attr(name="cvl")
    status: str = attr()
    fluid: str = attr(name="fld")
    fluid_units: str = attr(name="fldu")
    meniscus_x: float = attr(name="x")
    meniscus_y: float = attr(name="y")
    s_value_fixme: float = attr(name="s")
    dmso_homogeneous: float = attr(name="fsh")
    dmso_imhomogeneous: float = attr(name="fsinh")
    fluid_thickness: float = attr(name="t")
    current_fluid_thickness: float = attr(name="ct")
    bottom_thickness: float = attr(name="b")
    fluid_thickness_homogeneous: float = attr(name="fth")
    fluid_thickness_imhomogeneous: float = attr(name="ftinh")
    outlier: float = attr(name="o")
    corrective_action: str = attr(name="a")


class SignalFeature(BaseXmlModel, tag="f"):
    feature_type: str = attr(name="t")
    tof: float = attr(name="o")
    vpp: float = attr(name="v")


class EchoSignal(BaseXmlModel, tag="e"):
    signal_type: str = attr(name="t")
    transducer_x: float = attr(name="x")
    transducer_y: float = attr(name="y")
    transducer_z: float = attr(name="z")
    features: list[SignalFeature]


class PlateSurveyXML(BaseXmlModel, tag="platesurvey"):
    """A platesurvey XML model for files generated by the Medman / 'Echo Liquid Handler' software."""

    plate_type: str = attr(name="name")
    """The `name` attribute.  Practically appears to always be the plate type."""
    plate_barcode: str = attr(name="barcode")
    """Plate barcode, if present, or `"UnknownBarCode"`. `barcode` attribute."""
    timestamp: datetime = attr(name="date")
    """Timestamp of the survey.  `date` attribute."""
    machine_serial_number: str = attr(name="serial_number")
    vtl: int = attr(name="vtl")  # fixme
    original: int = attr(name="original")  # fixme
    data_format_version: int = attr(name="frmt")  # fixme
    rows: int = attr(name="rows")
    columns: int = attr(name="cols")
    total_wells: int = attr(name="totalWells")
    wells: list[WellSurvey]
    plate_name: str | None = attr(name="plate_name", default=None)
    """Plate name.  Additional attribute, added by echo_utils."""
    note: str | None = attr(name="note", default=None)
    """Comment.  Additional attribute, added by echo_utils."""


class EchoReportHeader(BaseXmlModel, tag="reportheader"):
    RunID: str = element()
    RunDateTime: datetime = element()
    AppName: str = element()
    AppVersion: str = element()
    ProtocolName: str = element()
    OrderID: str = element()  # FIXME
    ReferenceID: str = element()  # FIXME
    UserName: str = element()
    Comment: str | None = element(default=None)
    """Comment. Additional element, added by echo_utils."""

    @model_validator(mode="after")
    def warn_on_untested_versions(self) -> "EchoReportHeader":
        version = self.AppVersion
        version_triple = version.split(".")
        if len(version_triple) != 3:
            log.warning(
                f"Unexpected version format {self.AppVersion} for {self.AppName}.  There may be errors in parsing."
            )
            return self
        major, minor, patch = version_triple

        match self.AppName:
            case "Echo Plate Reformat" | "Echo Cherry Pick":
                if major != "1":
                    log.warning(
                        f"Unexpected major version {version} for {self.AppName}.  There may be errors in parsing. This library has been tested on 1.8.2."
                    )
                elif minor != "8":
                    log.warning(
                        f"Untested minor version {version} for {self.AppName}.  There may be errors in parsing.  This library has been tested on 1.8.2."
                    )
                elif patch != "2":
                    log.info(
                        f"Untested patch version {version} for {self.AppName}.  This library has been tested on 1.8.2."
                    )
            case _:
                log.warning(
                    f"Unknown application {self.AppName} {version} generated this survey.  There may be errors in parsing."
                )

        return self


class EchoReportRecord(BaseXmlModel, tag="record"):
    SrcPlateName: str = element()
    SrcPlateBarcode: str = element()
    SrcPlateType: str = element()
    SrcWell: str = element()
    SurveyFluidHeight: float = element()
    SurveyFluidVolume: float = element()
    FluidComposition: float = element()  # FIXME
    FluidUnits: str = element()  # FIXME
    FluidType: str = element()
    SurveyStatus: str = element()  # FIXME)


class EchoReportFooter(BaseXmlModel, tag="reportfooter"):
    InstrName: str = element()
    InstrModel: str = element()
    InstrSN: str = element()
    InstrSWVersion: str = element()


class EchoReportBody(BaseXmlModel, tag="reportbody"):
    records: list[EchoReportRecord]

    @model_validator(mode="after")
    def check_equal_plate_names(self) -> "EchoReportBody":
        if len(names := set([r.SrcPlateName for r in self.records])) != 1:
            raise ValueError(
                f"All records must have the same SrcPlateName, but the names {names} were found. "
                "This is unexpected but supported by the format, please file an issue."
            )
        return self

    @model_validator(mode="after")
    def check_equal_plate_barcodes(self) -> "EchoReportBody":
        if len(barcodes := set([r.SrcPlateBarcode for r in self.records])) != 1:
            raise ValueError(
                f"All records must have the same SrcPlateBarcode, but the barcodes {barcodes} were found. "
                "This is unexpected but supported by the format, please file an issue."
            )
        return self

    @model_validator(mode="after")
    def check_equal_plate_types(self) -> "EchoReportBody":
        if len(types := set([r.SrcPlateType for r in self.records])) != 1:
            raise ValueError(
                f"All records must have the same SrcPlateType, but the types {types} were found. "
                "This is unexpected but supported by the format, please file an issue."
            )
        return self


class EchoSurveyReport(BaseXmlModel, tag="report"):
    reportheader: EchoReportHeader
    reportbody: EchoReportBody
    reportfooter: EchoReportFooter


class Survey:
    """An class for all Echo plate surveys.

    This class holds results from Echo plate surveys, regardless of source.  It currently
    supports:

      - Medman / raw surveys
      - Cherry Pick surveys
    """

    raw: PlateSurveyXML | EchoSurveyReport

    @property
    def plate_barcode(self) -> str | None:
        match self.raw:
            case PlateSurveyXML():
                bc = self.raw.plate_barcode
            case EchoSurveyReport():
                bc = self.raw.reportbody.records[0].SrcPlateBarcode  # FIXME
            case _:
                raise ValueError("Unknown survey type")
        if bc == "UnknownBarCode":
            return None
        else:
            return bc

    @property
    def plate_name(self) -> str:
        match self.raw:
            case PlateSurveyXML():
                return self.raw.plate_name
            case EchoSurveyReport():
                return self.raw.reportbody.records[0].SrcPlateName

    @plate_name.setter
    def plate_name(self, value: str) -> None:
        match self.raw:
            case PlateSurveyXML():
                self.raw.plate_name = value
            case EchoSurveyReport():
                for record in self.raw.reportbody.records:
                    record.SrcPlateName = value

    @property
    def date(self) -> datetime | None:
        match self.raw:
            case PlateSurveyXML():
                return self.raw.timestamp
            case EchoSurveyReport():
                return self.raw.reportheader.RunDateTime
            case _:
                raise ValueError("Unknown survey type")

    @property
    def well_extents(self) -> tuple[int, int, int, int]:
        """Return the extents of the wells in the survey."""
        df = self._dataframe
        return (
            df.get_column("row").min(),
            df.get_column("row").max() + 1,  # type: ignore
            df.get_column("column").min(),
            df.get_column("column").max() + 1,  # type: ignore
        )  # type: ignore

    @property
    def shape(self) -> tuple[int, int]:
        return (
            self.well_extents[1] - self.well_extents[0],
            self.well_extents[3] - self.well_extents[2],
        )

    @property
    def _dataframe(self) -> pl.DataFrame:
        match self.raw:
            case PlateSurveyXML():
                return pl.DataFrame(
                    {
                        "well": [w.well for w in self.raw.wells],
                        "row": [w.row for w in self.raw.wells],
                        "column": [w.column for w in self.raw.wells],
                        "volume": [w.volume for w in self.raw.wells],
                    }
                )
            case EchoSurveyReport():
                return pl.DataFrame(
                    {
                        "well": [r.SrcWell for r in self.raw.reportbody.records],
                        "row": [
                            _WELL_ALPHABET.index(r.SrcWell[0])
                            for r in self.raw.reportbody.records
                        ],
                        "column": [
                            int(r.SrcWell[1:]) - 1 for r in self.raw.reportbody.records
                        ],
                        "volume": [
                            r.SurveyFluidVolume for r in self.raw.reportbody.records
                        ],
                    }
                )
            case _:
                raise ValueError("Unknown survey type")

    @property
    def volumes_array(self) -> np.ndarray:
        """Returns an array of volumes."""
        arr = np.full(self.shape, np.nan)
        we = self.well_extents
        df = self._dataframe
        arr[
            df.get_column("row") - we[0], df.get_column("column") - we[2]
        ] = df.get_column("volume")
        return arr

    def plot_volumes(
        self,
        ax: "Axes | None" = None,
        annot: bool = True,
        annot_fmt: str = ".0f",
        cbar: bool = False,
        title: str | Callable | None = None,
    ) -> "Axes":
        import matplotlib.pyplot as plt
        import seaborn as sns

        rstart, rend, cstart, cend = self.well_extents

        va = self.volumes_array
        if ax is None:
            fig, ax = plt.subplots(figsize=(6 + int(cbar), 4))

        p = sns.heatmap(
            va,
            annot=annot,
            fmt=annot_fmt,
            cmap="viridis",
            ax=ax,
            cbar=cbar,
            cbar_kws={"label": "well volume (µL)"},
            annot_kws={"fontsize": 6},
        )

        assert ax is not None
        # put x tick labels on top
        ax.xaxis.tick_top()
        ax.set_aspect("equal")
        # set y tick labels by alphabet
        ax.set_yticklabels(_WELL_ALPHABET[rstart:rend])
        ax.set_xticklabels([str(i + 1) for i in range(cstart, cend)])

        if title is None:
            te = ["Volumes"]
            if self.plate_barcode:
                te.append(f"of {self.plate_barcode}")
            if self.date:
                te.append(f"on {self.date}")
            title = " ".join(te)
        elif isinstance(title, str):
            title = title.format(self)
        else:
            title = title(self)

        ax.set_title(title)
        return p

    def __init__(self, raw: PlateSurveyXML | EchoSurveyReport):
        self.raw = raw

    @classmethod
    def from_file(cls, path: os.PathLike | str) -> "Survey":
        """Create a Survey from an XML string."""
        xml_data = open(path, "rb").read()

        errors = []

        try:
            raw = PlateSurveyXML.from_xml(xml_data)
            return cls(raw)
        except Exception as e:
            errors.append(e)
            pass

        try:
            raw = EchoSurveyReport.from_xml(xml_data)
            return cls(raw)
        except Exception as e:
            errors.append(e)
            pass

        raise ValueError(f"Cannot parse {path} as a survey: {errors}") from Exception(
            errors
        )
